{"version":3,"sources":["inspectors/schema.js"],"names":[],"mappings":";;;;;;;;;;6BAAkB,mBAAmB;;;;qBACM,OAAO;;;;;;;;;;;;;AAalD,SAAS,MAAM,CAAC,EAAE,EAAE,IAAI,EAAE;AACxB,SAAO,gCAAM,EAAE,EAAE,cAAc,EAAE,EAAC,IAAI,EAAE,IAAI,EAAC,CAAC,CAC3C,IAAI,CAAC,UAAA,OAAO;WAAI,KAAK,CAAC,IAAI,EAAE,OAAO,CAAC;GAAA,CAAC,CAAC;CAC1C;;;;;;;;;;AAUD,SAAS,KAAK,CAAC,IAAI,EAAE,OAAO,EAAE;AAC5B,SAAO;AACL,WAAO,EAAK,yCAAyC;AACrD,SAAK,EAAO,IAAI;AAChB,QAAI,EAAQ,QAAQ;AACpB,cAAU,EAAE,UAAU,CAAC,OAAO,CAAC;AAC/B,YAAQ,EAAI,QAAQ,CAAC,OAAO,CAAC;GAC9B,CAAC;CACH;;;;;;;;;;AAUD,SAAS,UAAU,CAAC,OAAO,EAAE;AAC3B,MAAI,gBAAgB,GAAG,gBAAI,QAAQ,EAAE,OAAO,CAAC,CAAC;AAC9C,SAAO,qBAAS,gBAAgB,CAAC,CAAC;CACnC;;;;;;;;;;;AAWD,SAAS,QAAQ,CAAC,MAAM,EAAE;AACxB,MAAM,KAAK,GAAG;AACZ,aAAS,EAAE,SAAS;AACpB,WAAO,EAAE,SAAS;AAClB,uBAAmB,EAAE,QAAQ;AAC7B,aAAS,EAAE,QAAQ;AACnB,QAAI,EAAE,QAAQ;AACd,UAAM,EAAE,SAAS;AACjB,sBAAkB,EAAE,QAAQ;AAC5B,WAAO,EAAE,SAAS;AAClB,QAAI,EAAE,QAAQ;AACd,SAAK,EAAE,QAAQ;AACf,WAAO,EAAE,QAAQ;AACjB,QAAI,EAAE,QAAQ;AACd,YAAQ,EAAE,SAAS;AACnB,eAAW,EAAE,SAAS;AACtB,UAAM,EAAE,SAAS;AACjB,QAAI,EAAE,QAAQ;AACd,4BAAwB,EAAE,QAAQ;AAClC,iCAA6B,EAAE,QAAQ;GACxC,CAAC;;AAEF,MAAI,MAAM,GAAG;AACX,QAAI,EAAE,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC;GACzB,CAAC;;AAEF,MAAI,MAAM,WAAQ,IAAI,MAAM,WAAQ,CAAC,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,EAAE;AACtD,UAAM,CAAC,QAAQ,GAAG,IAAI,CAAC;GACxB;;AAED,6BACG,MAAM,CAAC,IAAI,EAAG,MAAM,EACrB;CACH;;;;;;;;;;AAUD,SAAS,QAAQ,CAAC,OAAO,EAAE;AACzB,MAAM,UAAU,GAAG,SAAb,UAAU,CAAG,MAAM;WACvB,MAAM,CAAC,QAAQ,KAAK,KAAK,IAAI,MAAM,WAAQ,KAAK,IAAI;GAAA,CAAC;;AAEvD,MAAI,eAAe,GAAG,mBAAO,UAAU,EAAE,OAAO,CAAC,CAAC;AAClD,SAAO,kBAAM,MAAM,EAAE,eAAe,CAAC,CAAC;CACvC;;qBAEc,MAAM;QACb,KAAK,GAAL,KAAK;QAAE,QAAQ,GAAR,QAAQ;QAAE,UAAU,GAAV,UAAU;QAAE,QAAQ,GAAR,QAAQ","file":"inspectors/schema.js","sourcesContent":["import query from '../util/fileQuery';\nimport {map, mergeAll, filter, pluck} from 'ramda';\n\n/**\n * Inspects the column definitions for a table specified by `name`, and returns\n * a promise that will resolve to a JSON Schema v4 document. The resulting\n * schema document can be used to validate objects that are candidates for\n * insertion into table `name`.\n *\n * @function collimator.schema\n * @param {Promise.<Database>} db - The pg-promise connection\n * @param {String} name - The name of the table to get the schema of\n * @returns {Promise.<Object>} A promise that will resolve to the schema for the given table\n */\nfunction schema(db, name) {\n  return query(db, './schema.sql', {name: name})\n    .then(columns => table(name, columns));\n}\n\n/**\n * Creates a JSON Schema v4 document for a table `name` comprised of `columns`.\n *\n * @function collimator.schema.table\n * @param {String} name - The name of the column being documented\n * @param {Object[]} columns - The columns being documented\n * @returns {Object} The generated JSON Schema document\n */\nfunction table(name, columns) {\n  return {\n    $schema:    'http://json-schema.org/draft-04/schema#',\n    title:      name,\n    type:       'object',\n    properties: properties(columns),\n    required:   required(columns)\n  };\n}\n\n/**\n * Maps over an array of `columns` to generate a schema definition for each\n * column, keyed by name.\n *\n * @function collimator.schema.properties\n * @param {Object[]} columns - The columns to document\n * @returns {Object} The generated JSON Schema properties object, keyed by column name\n */\nfunction properties(columns) {\n  var columnProperties = map(property, columns);\n  return mergeAll(columnProperties);\n}\n\n/**\n * Dcouments a single column according to JSON Schema semantics.  A\n * non-standard `readonly` property will be added to columns that use a default\n * value generated by an expression, eg `now()` or `nextval()`.\n *\n * @function collimator.schema.property\n * @param {Object} column - The column to document\n * @returns {Object} The generated JSON Schema property object\n */\nfunction property(column) {\n  const TYPES = {\n    bigserial: 'integer',\n    boolean: 'boolean',\n    'character varying': 'string',\n    character: 'string',\n    date: 'string',\n    bigint: 'integer',\n    'double precision': 'number',\n    integer: 'integer',\n    json: 'object',\n    jsonb: 'object',\n    numeric: 'number',\n    real: 'number',\n    smallint: 'integer',\n    smallserial: 'integer',\n    serial: 'integer',\n    text: 'string',\n    'time without time zone': 'string',\n    'timestamp without time zone': 'string'\n  };\n\n  var schema = {\n    type: TYPES[column.type]\n  };\n\n  if (column.default && column.default.indexOf('(') > -1) {\n    schema.readonly = true;\n  }\n\n  return {\n    [column.name]: schema\n  };\n}\n\n/**\n * Determines the required properties by looking for `columns` that are not\n * nullable and do not specify a default value\n *\n * @function collimator.schema.required\n * @param {Object[]} columns - The columns to document\n * @returns {String[]} Names of required columns\n */\nfunction required(columns) {\n  const isRequired = column =>\n    column.nullable === false && column.default === null;\n\n  var requiredColumns = filter(isRequired, columns);\n  return pluck('name', requiredColumns);\n}\n\nexport default schema;\nexport {table, property, properties, required};\n"],"sourceRoot":"/source/"}